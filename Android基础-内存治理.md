#### 你做过哪些内存治理相关的工作？要治理哪些问题？

OOM：所申请的内存 > 可分配内存 - 已分配内存

内存抖动：申请的内存过大 -> 创建了大型实例或短时间内创建了非常多的小实例

内存泄漏：实例的生命周期结束后依然存在GCRoot的引用链条上，垃圾回收器依然认为实例有用

内存治理三板斧：回收 压缩 复用

1. 堆内存溢出

   1. 垃圾回收 STW

       STW：Stop the world：GC的同时暂停一切用户线程

      - 并行、并发回收
      - 缩小回收范围

   2. 内存分配 OOM 

   解决内存抖动、内存泄露

2. 线程数超限

   线程数超限 OOM 消灭野线程

3. FD泄漏

   FD 也叫文件句柄，在 Linux 里，文件、目录、块设备、字符设备、管道等都被抽象成了文件，所以在调用这些文件的时候，都会返回一个 FD。

   FD数超限 OOM

   FD泄漏原因是FD没有及时释放：文件未正常关闭、I/O未正常关闭、Cursor未正常关闭

   治理思路：及时关闭I/O操作、及时关闭数据库和Cursor、及时释放HandlerThread




Bitmap 内存治理：三级缓存

- 能控制内存总占用
- 避免重复创建 Bitmap



#### Activity 内存泄漏可能原因

- Activity 被静态变量或单例所持有
- 被其他长生命周期实例持有
- 注意：尽量别作为参数传递Activity
- 注意：Activity 生命周期结束时取消异步任务

OOM：pthread_create failed.

- 系统分配线程栈失败
  - 系统内存不足的时候启动线程
  - 进程内运行的线程数超过了系统的限制，需要控制并发线程数来解决
  - 使用线程池或 Kotlin 协程



#### 一些好的编码习惯

- 谨慎使用static、顶层变量和单例
- 关注内部类的生命周期
- 注册与反注册要成对出现
- 需要context的情况尽量使用Application Context
- 酌情使用枚举
- 尽量避免自动拆装箱
- 避免过度的页面绘制
- 及时关闭I/O和Cursor
- 及时释放HandlerThread
